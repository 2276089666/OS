# OS

### 1.OS演变过程(单机)

1. 无操作系统(串行处理)

   >- 人工操作----------------人工装入任务,运行完毕后,只有取走任务结果,下个任务才能执行.
   >- 脱机输入/输出方式--------------------脱机,将运行的结果打印到纸带上,直接开始下一个任务,结果已经持久化了.

2. 单道批处理系统

   >将一堆作业放在**disk**(磁盘)上,用户不再干预,由系统中的Monitor一次从**disk**调入一个任务到内存中执行,任务独享整个主存
   >
   >缺点: 吞吐量小,CPU的利用率低,任务处于I/O等非计算状态时,CPU空闲

3. 多道批处理系统

   >把一堆作业提前放在**disk**上,由Monitor**进行作业调度选择若干作业**到内存中并为之创建进程,然后调度运行,多个任务共享CPU和内存资源等
   >
   >缺点:无交互能力,任务交给操作系统后,人工不能干预

4. 分时系统

   >**多作业不用提前放在disk而是直接进入内存**,方便多用户可以在终端输入数据对自己的任务做出修改,每个任务占有CPU的时间由**时间片**决定,多个任务共享CPU和内存资源等

其他功能的OS:

1. 实时系统

   >必须对所接收的某些信号做出""及时"或"实时"的反应

------

### 2.OS总体结构

![image-20210701164430079](README.assets/image-20210701164430079.png)



![image-20210701164643687](README.assets/image-20210701164643687.png)

#### 2.1.OS基础平台子系统风格

##### 2.1.1.分层方式:

1. 分层

   >上层只依赖**直接下层**

2. 分级

   >上层只依赖**下层**

3. 分块

   >所有模块都可**任意引用其他模块**

![image-20210701170424714](README.assets/image-20210701170424714.png)

##### 2.1.2.分模式方式:

1. 多模式

   >包含多个模式模块,其由应用软件,基础平台子系统组成.不同的模式模块在不同的CPU特权下执行
   >
   >主要处于安全考虑,不同的app运行在可能不同的级别的保护模式下,需要切换,和安全判断

2. 单模式

   >应用软件,基础平台子系统在同一个CPU特权下执行
   >
   >实例:DOS  app和os在同一模式下,不需要切换,在封闭无网络的情况下,效率高

   ![image-20210701172505896](README.assets/image-20210701172505896.png)

3. 双模式

   >俗称用户态和内核态
   >
   >实例:linux

##### 2.1.3.微内核

```
尽最大努力剔除核心子系统中多余的部分,并把它们移到核外子系统中实现,核心子系统只实现一些必要的简单概念及其属性,从而保持核心子系统简洁高效
实例:分布式OS鸿蒙
```

------

### 3.OS资源管理

![image-20210702160338333](README.assets/image-20210702160338333.png)

#### 3.1.Memory Tables

![image-20210702161010953](README.assets/image-20210702161010953.png)

#### 3.2.I/O Tables

![image-20210702161515083](README.assets/image-20210702161515083.png)

#### 3.3.File Tables

![image-20210702162939419](README.assets/image-20210702162939419.png)

#### 3.4.Processes Tables

![image-20210702163158192](README.assets/image-20210702163158192.png)

------

![image-20210702163447141](README.assets/image-20210702163447141.png)

------

<img src="README.assets/image-20210702163520296.png" alt="image-20210702163520296" style="zoom:80%;" />

------

### 4.OS进程管理

#### 4.1.七状态转换图(状态都在PCB中)

![image-20210702154712003](README.assets/image-20210702154712003.png)

- Suspend(挂起):

>**原因**:CPU的速度远超I/O的速度,所以可能全部的进程都在等待I/O,为了腾出更多的memory,采用swap将暂时不能运行的进程或数据交换到disk上,进程状态变为Supend,**但是PCB还在内存**
>
>**造成Suspend情况**:
>
>1. OS的周期性的检查进程,在周期未到达时,处于挂起状态
>2. 用户debug某个正在运行的进程
>3. 时钟中断
>4. 父进程请求子进程挂起,以便考察和修改子进程，或者协调各子进程间的活动

<img src="README.assets/image-20210702152742394.png" alt="image-20210702152742394" style="zoom:80%;" />

- Blocked和Suspend区别:

<img src="README.assets/image-20210702152957351.png" alt="image-20210702152957351" style="zoom:80%;" />

- **当进程就绪队列为空时:**

<img src="README.assets/image-20210702153701525.png" alt="image-20210702153701525" style="zoom:80%;" />

------



#### 4.2.PCB里面的信息

<img src="README.assets/image-20210702164138440.png" alt="image-20210702164138440" style="zoom:80%;" />

------

![image-20210702164237393](README.assets/image-20210702164237393.png)

------

![image-20210702164719337](README.assets/image-20210702164719337.png)

------

![image-20210702170720899](README.assets/image-20210702170720899.png)

------

![image-20210702171034928](README.assets/image-20210702171034928.png)

------

![image-20210702171200978](README.assets/image-20210702171200978.png)

------

![image-20210702171351226](README.assets/image-20210702171351226.png)

------

![image-20210702171840363](README.assets/image-20210702171840363.png)

------

![image-20210702172151041](README.assets/image-20210702172151041.png)

------

![image-20210702172435921](README.assets/image-20210702172435921.png)

------

#### 4.3.原语

>若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断,可以看成原子操作

以下进程的状态的切换都是由原语完成:

![image-20210702183240134](README.assets/image-20210702183240134.png)







##### 模式切换

>app触发系统调用,会触发**软中断**(判断此次调用是否合法,是否有足够的权限),进而从用户态切换到内核态去执行相应的系统函数
>
>模式切换**可能**会造成进程切换

##### 4.3.1.进程切换

>收回当前进程的cpu,准备把它分派给某个就绪的进程
>
>进程切换**必然**会造成模式切换(**需要通过模式切换到内核态,运行进程的调度程序**)

进程切换的步骤:

![image-20210702183648144](README.assets/image-20210702183648144.png)

![image-20210702183833182](README.assets/image-20210702183833182.png)

##### 4.3.2.进程创建

触发条件:

![image-20210702192254331](README.assets/image-20210702192254331.png)

进程创建步骤:

<img src="README.assets/image-20210702190317964.png" alt="image-20210702190317964" style="zoom:80%;" />

##### 4.3.3.进程终止

触发条件:

![image-20210702192549887](README.assets/image-20210702192549887.png)

触发原因:

![image-20210702192621205](README.assets/image-20210702192621205.png)

<img src="README.assets/image-20210702192649868.png" alt="image-20210702192649868" style="zoom:80%;" />

进程终止步骤:

<img src="README.assets/image-20210702192829418.png" alt="image-20210702192829418" style="zoom:80%;" />

##### 4.3.4.进程阻塞与唤醒

阻塞触发条件:

![image-20210702193148129](README.assets/image-20210702193148129.png)

<img src="README.assets/image-20210702193747504.png" alt="image-20210702193747504" style="zoom:80%;" />

##### 4.3.5.进程挂起与激活

挂起触发条件:

>1. OS的周期性的检查进程,在周期未到达时,处于挂起状态
>2. 用户debug某个正在运行的进程
>3. 时钟中断
>4. 父进程请求子进程挂起,以便考察和修改子进程，或者协调各子进程间的活动

<img src="README.assets/image-20210702193955854.png" alt="image-20210702193955854" style="zoom:80%;" />

### 5.OS线程

>同一个进程的多个线程共享进程的资源,是调度基本单位

线程优点:

![image-20210702195555278](README.assets/image-20210702195555278.png)

注意:

- 挂起一个进程,该进程内的所有线程也被挂起,原因:进程里面的所有线程共享相同的地址空间
- 终止一个进程,该进程内的所有线程也终止

#### 5.1.不同OS对线程的支持:

1. DOS:单线程
2. Unix:多用户多进程+多线程
3. linux:多用户单进程+多线程
4. windows:单进程+多线程

#### 5.2.线程分类:

1. 用户线程: 用户态的线程,kernel不知道有多少个用户线程,没有TCB(线程的控制块),不归它调度
2. 内核线程:内核态的线程,由内核调度,有更高的访问权限

#### 5.3.线程和进程的三种对应模型

![image-20210702201118558](README.assets/image-20210702201118558.png)



------

# Linux OS



### 僵尸进程

​	父进程产生子进程后,会维护子进程的一个PCB结构,子进程退出,由父进程释放,

如果父进程没有释放,那么子进程会成为一个僵尸进程

```shell
ps -ef | grep defuct
```

### 孤儿进程

​	子进程结束之前,父进程已经退出.孤儿进程会成为init进程的孩子,由1号进程维护

### 进程调度方式

1. 非抢占式: 	一旦把处理机分配给某进程后,就一直让他运行下去,绝不会因为时钟中断或任何其他原因去抢占当前正在运行的处理机,直至该进程完成,或发生某事件而被阻塞时,才把处理机分配给其他进程.
2. 抢占式:         允许调度程序根据某种原则,去暂停某个正在执行的进程,将已经分配给该进程的处理机重新分配给另一进程.

### linux进程调度算法

1. linux2.5 经典的O(1)调度策略,**每个进程轮询的给固定的时间片**

   **缺点**:偏向服务器,对交互不友好(有些进程可能不需要处理机了,但是还被分配了时间片,导致正真需要时间片进程没能及时得到时间片)

2. linux 2.6.23 采用CFS完全公平的调度算法:**按优先级分配时间片的比例,记录每个进程的执行时间,如果有一个进程执行时间不到它应该分配的比例,该进程优先执行**

### 进程类型

- IO密集型:大部分时间用于等待IO
- CPU密集型:大部分时间用于计算

### 进程优先级

实时进程(0~99级)>普通进程(-20-99)

值越小优先级越高

### 默认的调度策略

对于实时进程:

> **优先级不同**FIFO(谁优先级高谁先进,先进先出),**优先级相同**的RR(轮询)

对于普通进程:

> 上面的CFS

### 内存管理

#### 多个进程装入内存导致的问题:

- 内存大小不够用:**分页(用哪部分加载哪部分)**  + LRU(最不经常使用内存置换算法)**置换出来的数据放在swap交换分区的硬盘里**

- **进程间相互干扰**+**直接操作物理内存不安全**:

  > 虚拟内存:
  >
  > ​	让进程工作在虚拟空间,程序中用到的空间地址不再是直接的物理地址,而是虚拟地址,这样,A进程永远不可能访问到B进程的空间,虚拟内存比物理空间大很多,64位操作系统的虚拟空间2^64bit,由于虚拟空间被分成不同的段,我们的进程需要使用的内存也会分布到虚拟内存的不同的段中.所以,在虚拟的角度进程独享整个系统+CPU
  
  

![image-20210604104529401](README.assets/image-20210604104529401.png)

#### 虚拟内存到物理内存的映射问题:

1. 偏移量+段的基地址=线性地址(虚拟空间)
2. 线性地址+OS+MMU(内存管理单元)=物理地址



